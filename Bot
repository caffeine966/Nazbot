import os
import requests
import pandas as pd
import numpy as np
from telegram import Bot
from telegram.ext import Application, CommandHandler, ContextTypes
from telegram import Update
import asyncio
from datetime import datetime
import ta
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(**name**)

# ===== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª =====

TELEGRAM_TOKEN = os.environ.get(â€œTELEGRAM_TOKENâ€, â€œØ¶Ø¹_ØªÙˆÙƒÙ†_Ø§Ù„ØªÙŠÙ„ÙŠØºØ±Ø§Ù…_Ù‡Ù†Ø§â€)
CHAT_ID = os.environ.get(â€œCHAT_IDâ€, â€œØ¶Ø¹_chat_id_Ù‡Ù†Ø§â€)

# Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ù„Ù„ØªØ­Ù„ÙŠÙ„

COINS = [
â€œBTC-USDTâ€, â€œETH-USDTâ€, â€œBNB-USDTâ€, â€œSOL-USDTâ€, â€œXRP-USDTâ€,
â€œADA-USDTâ€, â€œDOGE-USDTâ€, â€œAVAX-USDTâ€, â€œLINK-USDTâ€, â€œDOT-USDTâ€,
â€œMATIC-USDTâ€, â€œLTC-USDTâ€, â€œUNI-USDTâ€, â€œATOM-USDTâ€, â€œFTM-USDTâ€,
â€œNEAR-USDTâ€, â€œAPT-USDTâ€, â€œARB-USDTâ€, â€œOP-USDTâ€, â€œSUI-USDTâ€,
â€œINJ-USDTâ€, â€œTIA-USDTâ€, â€œJTO-USDTâ€, â€œWLD-USDTâ€, â€œSEI-USDTâ€
]

MAX_SIGNALS_PER_DAY = 5
signals_today = []
last_signal_date = None

def get_okx_candles(symbol, timeframe=â€œ1Hâ€, limit=100):
â€œâ€â€œØ¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ù…Ø¹Ø§Øª Ù…Ù† OKXâ€â€â€
try:
url = fâ€https://www.okx.com/api/v5/market/candlesâ€
params = {
â€œinstIdâ€: symbol,
â€œbarâ€: timeframe,
â€œlimitâ€: limit
}
response = requests.get(url, params=params, timeout=10)
data = response.json()

```
    if data.get("code") != "0" or not data.get("data"):
        return None
    
    candles = data["data"]
    df = pd.DataFrame(candles, columns=["timestamp", "open", "high", "low", "close", "vol", "volCcy", "volCcyQuote", "confirm"])
    df = df.astype({"open": float, "high": float, "low": float, "close": float, "vol": float})
    df = df.iloc[::-1].reset_index(drop=True)
    return df
except Exception as e:
    logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª {symbol}: {e}")
    return None
```

def get_liquidity(symbol):
â€œâ€â€œØ¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³ÙŠÙˆÙ„Ø©â€â€â€
try:
url = fâ€https://www.okx.com/api/v5/market/tickerâ€
params = {â€œinstIdâ€: symbol}
response = requests.get(url, params=params, timeout=10)
data = response.json()

```
    if data.get("code") != "0" or not data.get("data"):
        return 0
    
    ticker = data["data"][0]
    volume_24h = float(ticker.get("vol24h", 0))
    return volume_24h
except:
    return 0
```

def analyze_coin(symbol):
â€œâ€â€œØªØ­Ù„ÙŠÙ„ Ø¹Ù…Ù„Ø© ÙˆØ§Ø­Ø¯Ø©â€â€â€
# Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
df_1h = get_okx_candles(symbol, â€œ1Hâ€, 100)
df_4h = get_okx_candles(symbol, â€œ4Hâ€, 50)

```
if df_1h is None or len(df_1h) < 50:
    return None

close = df_1h["close"]
high = df_1h["high"]
low = df_1h["low"]
volume = df_1h["vol"]

# === Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª ===
# RSI
rsi = ta.momentum.RSIIndicator(close, window=14).rsi().iloc[-1]

# MACD
macd_indicator = ta.trend.MACD(close)
macd = macd_indicator.macd().iloc[-1]
macd_signal = macd_indicator.macd_signal().iloc[-1]
macd_diff = macd_indicator.macd_diff().iloc[-1]

# EMA
ema20 = ta.trend.EMAIndicator(close, window=20).ema_indicator().iloc[-1]
ema50 = ta.trend.EMAIndicator(close, window=50).ema_indicator().iloc[-1]
ema200 = ta.trend.EMAIndicator(close, window=200).ema_indicator() if len(close) >= 200 else None

# Bollinger Bands
bb = ta.volatility.BollingerBands(close, window=20)
bb_upper = bb.bollinger_hband().iloc[-1]
bb_lower = bb.bollinger_lband().iloc[-1]
bb_middle = bb.bollinger_mavg().iloc[-1]

# ATR Ù„Ù„Ù…Ø®Ø§Ø·Ø±
atr = ta.volatility.AverageTrueRange(high, low, close, window=14).average_true_range().iloc[-1]

# Stochastic
stoch = ta.momentum.StochasticOscillator(high, low, close)
stoch_k = stoch.stoch().iloc[-1]
stoch_d = stoch.stoch_signal().iloc[-1]

current_price = close.iloc[-1]

# === ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© ===
score = 0
reasons = []

# RSI
if rsi < 30:
    score += 3
    reasons.append("RSI ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø°Ø±ÙˆØ© Ø§Ù„Ø¨ÙŠØ¹ ğŸ“‰")
elif rsi < 45:
    score += 1
    reasons.append("RSI Ù…Ù†Ø®ÙØ¶")
elif rsi > 70:
    score -= 3
    reasons.append("RSI ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø°Ø±ÙˆØ© Ø§Ù„Ø´Ø±Ø§Ø¡ âš ï¸")
elif rsi > 55:
    score += 1

# MACD
if macd > macd_signal and macd_diff > 0:
    score += 2
    reasons.append("MACD Ø¥ÙŠØ¬Ø§Ø¨ÙŠ âœ…")
elif macd < macd_signal and macd_diff < 0:
    score -= 2

# EMA
if current_price > ema20 > ema50:
    score += 2
    reasons.append("Ø§Ù„Ø³Ø¹Ø± ÙÙˆÙ‚ Ø§Ù„Ù…ØªÙˆØ³Ø·Ø§Øª ğŸ“ˆ")
elif current_price < ema20 < ema50:
    score -= 2

# Bollinger Bands
if current_price <= bb_lower * 1.02:
    score += 2
    reasons.append("Ø§Ù„Ø³Ø¹Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø³ÙÙ„ÙŠ Ù„Ø¨ÙˆÙ„ÙŠÙ†Ø¬Ø± ğŸ¯")
elif current_price >= bb_upper * 0.98:
    score -= 1

# Stochastic
if stoch_k < 20 and stoch_d < 20:
    score += 1
    reasons.append("Stochastic ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø°Ø±ÙˆØ© Ø§Ù„Ø¨ÙŠØ¹")
elif stoch_k > 80 and stoch_d > 80:
    score -= 1

# Volume
avg_volume = volume.rolling(20).mean().iloc[-1]
if volume.iloc[-1] > avg_volume * 1.5:
    score += 1
    reasons.append("Ø­Ø¬Ù… ØªØ¯Ø§ÙˆÙ„ Ù…Ø±ØªÙØ¹ ğŸ“Š")

# === ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„ØµÙÙ‚Ø© ===
signal_type = None
if score >= 4:
    signal_type = "LONG ğŸŸ¢"
elif score <= -3:
    signal_type = "SHORT ğŸ”´"

if not signal_type:
    return None

# === Ø­Ø³Ø§Ø¨ Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙˆØ§Ù„Ø®Ø±ÙˆØ¬ ===
atr_multiplier_tp = 2.0
atr_multiplier_sl = 1.2

if "LONG" in signal_type:
    entry = current_price
    tp1 = round(entry + (atr * atr_multiplier_tp * 0.6), 6)
    tp2 = round(entry + (atr * atr_multiplier_tp * 1.2), 6)
    tp3 = round(entry + (atr * atr_multiplier_tp * 2.0), 6)
    sl = round(entry - (atr * atr_multiplier_sl), 6)
    
    risk = entry - sl
    reward = tp2 - entry
else:
    entry = current_price
    tp1 = round(entry - (atr * atr_multiplier_tp * 0.6), 6)
    tp2 = round(entry - (atr * atr_multiplier_tp * 1.2), 6)
    tp3 = round(entry - (atr * atr_multiplier_tp * 2.0), 6)
    sl = round(entry + (atr * atr_multiplier_sl), 6)
    
    risk = sl - entry
    reward = entry - tp2

# Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø© Ù„Ù„Ø¹Ø§Ø¦Ø¯
rr_ratio = round(reward / risk, 2) if risk > 0 else 0

# Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø¬Ø§Ø­ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠØ©
success_rate = min(90, max(50, 50 + (score * 5)))

# Ù†ÙˆØ¹ Ø§Ù„ØµÙÙ‚Ø© (Ø³ÙƒØ§Ù„Ø¨ Ø£Ùˆ Ø³ÙˆÙŠÙ†Ù‚)
trade_type = "Ø³ÙƒØ§Ù„Ø¨ âš¡" if abs(score) < 6 else "Ø³ÙˆÙŠÙ†Ù‚ ğŸŒŠ"

return {
    "symbol": symbol,
    "signal": signal_type,
    "trade_type": trade_type,
    "entry": entry,
    "tp1": tp1,
    "tp2": tp2,
    "tp3": tp3,
    "sl": sl,
    "rr_ratio": rr_ratio,
    "success_rate": success_rate,
    "score": score,
    "reasons": reasons,
    "rsi": round(rsi, 1),
    "atr": round(atr, 6)
}
```

def format_signal(signal):
â€œâ€â€œØªÙ†Ø³ÙŠÙ‚ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø©â€â€â€
symbol_clean = signal[â€œsymbolâ€].replace(â€-USDTâ€, â€œâ€)

```
msg = f"""
```

ğŸš¨ **Ø¥Ø´Ø§Ø±Ø© ØªØ¯Ø§ÙˆÙ„ Ø¬Ø¯ÙŠØ¯Ø©** ğŸš¨
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’° **Ø§Ù„Ø¹Ù…Ù„Ø©:** {symbol_clean}/USDT
ğŸ“Š **Ø§Ù„Ù†ÙˆØ¹:** {signal[â€œsignalâ€]}
âš¡ **Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©:** {signal[â€œtrade_typeâ€]}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’µ **Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„:** {signal[â€œentryâ€]}
ğŸ¯ **TP1:** {signal[â€œtp1â€]}
ğŸ¯ **TP2:** {signal[â€œtp2â€]}
ğŸ¯ **TP3:** {signal[â€œtp3â€]}
ğŸ›‘ **ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©:** {signal[â€œslâ€]}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ˆ **Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©/Ø§Ù„Ø¹Ø§Ø¦Ø¯:** 1:{signal[â€œrr_ratioâ€]}
âœ… **Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø¬Ø§Ø­ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠØ©:** {signal[â€œsuccess_rateâ€]}%
ğŸ“‰ **RSI:** {signal[â€œrsiâ€]}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ **Ø£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ø¥Ø´Ø§Ø±Ø©:**
â€œâ€â€
for reason in signal[â€œreasonsâ€]:
msg += fâ€â€¢ {reason}\nâ€

```
msg += f"""â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

âš ï¸ **ØªØ­Ø°ÙŠØ±:** Ù‡Ø°Ù‡ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ù„Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ÙÙ‚Ø·ØŒ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø± Ù…Ø³Ø¤ÙˆÙ„ÙŠØªÙƒ
ğŸ• {datetime.now().strftime(â€%Y-%m-%d %H:%Mâ€)}
â€œâ€â€
return msg

async def scan_markets():
â€œâ€â€œÙ…Ø³Ø­ Ø§Ù„Ø³ÙˆÙ‚ ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øªâ€â€â€
global signals_today, last_signal_date

```
today = datetime.now().date()
if last_signal_date != today:
    signals_today = []
    last_signal_date = today

if len(signals_today) >= MAX_SIGNALS_PER_DAY:
    logger.info("ÙˆØµÙ„Ù†Ø§ Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„ÙŠÙˆÙ…")
    return

bot = Bot(token=TELEGRAM_TOKEN)

# ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø³ÙŠÙˆÙ„Ø©
coins_with_liquidity = []
for coin in COINS:
    liq = get_liquidity(coin)
    if liq > 0:
        coins_with_liquidity.append((coin, liq))

coins_with_liquidity.sort(key=lambda x: x[1], reverse=True)
top_coins = [c[0] for c in coins_with_liquidity[:25]]

signals_found = []

for symbol in top_coins:
    if len(signals_today) + len(signals_found) >= MAX_SIGNALS_PER_DAY:
        break
    
    result = analyze_coin(symbol)
    if result:
        # ØªØ­Ù‚Ù‚ Ø¥Ù† Ù…Ø§ Ø£Ø±Ø³Ù„Ù†Ø§ Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„Ø© Ø§Ù„ÙŠÙˆÙ…
        if symbol not in signals_today:
            signals_found.append(result)

# Ø¥Ø±Ø³Ø§Ù„ Ø£ÙØ¶Ù„ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
signals_found.sort(key=lambda x: x["success_rate"], reverse=True)

for signal in signals_found[:MAX_SIGNALS_PER_DAY - len(signals_today)]:
    msg = format_signal(signal)
    await bot.send_message(chat_id=CHAT_ID, text=msg, parse_mode="Markdown")
    signals_today.append(signal["symbol"])
    await asyncio.sleep(2)

if not signals_found:
    logger.info("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø´Ø§Ø±Ø§Øª Ù‚ÙˆÙŠØ© Ø§Ù„Ø¢Ù†")
```

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
await update.message.reply_text(
â€œğŸ¤– Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø£Ù†Ø§ Ø¨ÙˆØª Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ\n\nâ€
â€œØ§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:\nâ€
â€œ/scan - Ù…Ø³Ø­ Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ø¢Ù†\nâ€
â€œ/status - Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª\nâ€
â€œ/help - Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©â€
)

async def scan_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
await update.message.reply_text(â€œğŸ” Ø¬Ø§Ø±ÙŠ Ù…Ø³Ø­ Ø§Ù„Ø³ÙˆÙ‚ØŒ Ø§Ù†ØªØ¸Ø±â€¦â€)
await scan_markets()
await update.message.reply_text(â€œâœ… Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ù…Ø³Ø­!â€)

async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
today = datetime.now().date()
count = len(signals_today) if last_signal_date == today else 0
await update.message.reply_text(
fâ€ğŸ“Š Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª:\nâ€
fâ€âœ… ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ\nâ€
fâ€ğŸ“¨ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„ÙŠÙˆÙ…: {count}/{MAX_SIGNALS_PER_DAY}\nâ€
fâ€ğŸ• Ø§Ù„ÙˆÙ‚Øª: {datetime.now().strftime(â€™%H:%Mâ€™)}â€
)

async def scheduled_scan(context):
â€œâ€â€œØ§Ù„Ù…Ø³Ø­ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ 4 Ø³Ø§Ø¹Ø§Øªâ€â€â€
await scan_markets()

async def main():
app = Application.builder().token(TELEGRAM_TOKEN).build()

```
# Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª
app.add_handler(CommandHandler("start", start_command))
app.add_handler(CommandHandler("scan", scan_command))
app.add_handler(CommandHandler("status", status_command))

# Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ù…Ø³Ø­ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ 4 Ø³Ø§Ø¹Ø§Øª
job_queue = app.job_queue
job_queue.run_repeating(scheduled_scan, interval=14400, first=60)

logger.info("ğŸ¤– Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„...")
await app.run_polling()
```

if **name** == â€œ**main**â€:
asyncio.run(main())
